{% extends "portfolio/base.html" %}
{% load portfolio_extras %}
{% load humanize %}

{% block title %}Target Allocations | CB3 Portfolio{% endblock %}

{% block content %}
<div class="row">
    <!-- Sidebar Column -->
    <div class="col-md-2 d-none d-md-block px-0">
        {% include "portfolio/sidebar.html" %}
    </div>

    <div class="col-md-10">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h1 class="h2 mb-0">Target Allocations</h1>
                <p class="text-muted mt-2">
                    Set default target allocations for each account type. 
                    Expand columns to override for specific accounts.
                    <br>
                    <small>Aggregate targets are calculated bottom-up based on account values.</small>
                </p>
            </div>
            <div>
                 <a href="{% url 'portfolio:dashboard' %}" class="btn btn-outline-secondary me-2">Cancel</a>
                 <button type="submit" form="allocation-form" id="save-button-top" class="btn btn-primary">Save Targets</button>
            </div>
        </div>

        <form method="post" id="allocation-form">
            {% csrf_token %}
            <div class="card shadow-sm">
                <div class="card-body p-0">
                    <div class="table-responsive">
                       {% include "portfolio/includes/allocation_table.html" with mode="percent" table_id="allocations-table" id_prefix="" %}
                    </div>
                </div>
            </div>

            <div class="mt-4 mb-3">
                <h3 class="h4">Target Values ($)</h3>
                <p class="text-muted small">Estimated target dollar values based on current portfolio size.</p>
            </div>
            
            <div class="card shadow-sm mb-4">
                <div class="card-body p-0">
                    <div class="table-responsive">
                         <!-- DOLLAR TABLE -->
                        {% include "portfolio/includes/allocation_table.html" with mode="dollar" table_id="allocations-table-money" id_prefix="money-" %}
                    </div>
                </div>
            </div>

            <div class="mt-3 text-end">
                <button type="submit" id="save-button-bottom" class="btn btn-primary">Save Targets</button>
            </div>
        </form>
    </div>
</div>

<!-- Data for JS -->
<script id="account-data" type="application/json">
{
    "account_values": {
        {% for at in account_types %}
            {% for acc in at.active_accounts %}
                "{{ acc.id }}": {{ acc.current_total_value|default:0 }},
            {% endfor %}
        {% endfor %}
        "null": 0 
    },
    "at_values": {
        {% for at in account_types %}
             "{{ at.id }}": {{ at_values|get_item:at.id|default:0 }},
        {% endfor %}
        "null": 0
    },
    "portfolio_total": {{ portfolio_total_value|default:0 }}
}
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const defaultInputs = document.querySelectorAll('.default-input');
    const overrideInputs = document.querySelectorAll('.override-input');
    const allInputs = [...defaultInputs, ...overrideInputs];
    const saveButtons = [document.getElementById('save-button-top'), document.getElementById('save-button-bottom')];
    const expandBtns = document.querySelectorAll('.expand-btn');
    
    // Parse Data
    const dataObj = JSON.parse(document.getElementById('account-data').textContent.replace(/,\s*}/, '}')); // remove trailing comma hack
    const accountValues = dataObj.account_values;
    const atValues = dataObj.at_values;
    const portfolioTotal = parseFloat(dataObj.portfolio_total);

    // Initial Toggle State (Sync both tables)
    expandBtns.forEach(btn => {
        btn.addEventListener('click', () => {
             const atId = btn.dataset.atId;
             const cols = document.querySelectorAll(`.col-acc-${atId}`);
             let isHidden = true;
             cols.forEach(col => {
                 if (col.classList.contains('d-none')) {
                     col.classList.remove('d-none');
                     isHidden = false;
                 } else {
                     col.classList.add('d-none');
                     isHidden = true;
                 }
             });
             btn.textContent = isHidden ? '[+]' : '[-]';
        });
    });

    function formatAccounting(val, decimals, prefix='', suffix='') {
        // Avoid "negative zero" and tiny floating point negatives showing as (0.0%).
        const rounded = parseFloat((val || 0).toFixed(decimals));
        const isNeg = rounded < 0;
        const absVal = Math.abs(rounded);
        const numStr = absVal.toLocaleString('en-US', {minimumFractionDigits: decimals, maximumFractionDigits: decimals});
        const result = `${prefix}${numStr}${suffix}`;
        
        if (isNeg) {
            return `(${result})`;
        }
        return result;
    }

    function formatPct(val) {
        return formatAccounting(val, 1, '', '%');
    }
    
    function formatMoney(val) {
        return formatAccounting(val, 0, '$', '');
    }

    function parseAccounting(str) {
         if (!str) return 0;
         const isNeg = str.includes('(');
         const cleaned = str.replace(/[^0-9.]/g, '');
         const val = parseFloat(cleaned) || 0;
         return isNeg ? -val : val;
    }
    
    // Core Calculation Logic
    function updateCalculations() {
        let valid = true;
        const invalidDefaultTotals = new Map();
        
        // 1. Gather Defaults: {atId: {acId: val}}
        const defaults = {};
        const defaultTotals = {}; // atId -> total (non-cash)
        const allAtIds = new Set();
        const atLabels = {};
        
        defaultInputs.forEach(inp => {
            const atId = inp.dataset.atId;
            const acId = inp.dataset.acId;
            const val = parseFloat(inp.value) || 0;

            allAtIds.add(atId);
            if (!atLabels[atId] && inp.dataset.atLabel) atLabels[atId] = inp.dataset.atLabel;
            
            // Only store non-zero values to avoid overwriting server-rendered targets
            if (val > 0) {
                if (!defaults[atId]) defaults[atId] = {};
                defaults[atId][acId] = val;
            }

            if (!defaultTotals[atId]) defaultTotals[atId] = 0;
            defaultTotals[atId] += val;
        });
        
        // 2. Gather Overrides: {accId: {acId: val}}
        const overrides = {};
        overrideInputs.forEach(inp => {
            const accId = inp.dataset.accId;
            const acId = inp.dataset.acId;
            const valStr = inp.value.trim();
            
            if (valStr !== '') {
                 if (!overrides[accId]) overrides[accId] = {};
                 overrides[accId][acId] = parseFloat(valStr);
            }
        });
        
        // 3. Compute Effective Targets & Aggregate
        const assetRows = document.querySelectorAll('tr[data-ac-id]'); // Matches rows in both tables? No, duplicate rows.
        // We iterate generic logic using keys.
        // But for DOM selection we should target the first table (allocations-table) for row iteration logic?
        // Actually we need to loop over assets.
        // Let's use specific selector for the first table rows to drive logic
        const primaryAssetRows = document.querySelectorAll('#allocations-table tr[data-ac-id]');
        
        const aggTargetDollars = {}; // acId -> dollars (percent-table only)
        const atTargetDollars = {}; // atId -> {acId: dollars} (percent-table only)
        let aggCashDollars = 0;
        const atCashDollars = {};
        
        const accountIds = new Set();
        overrideInputs.forEach(inp => accountIds.add(inp.dataset.accId));
        const accountAtMap = {};
        overrideInputs.forEach(inp => accountAtMap[inp.dataset.accId] = inp.dataset.atId);
        
        // Initialize agg maps
        primaryAssetRows.forEach(row => {
            const acId = row.dataset.acId;
            if (acId !== 'cash') aggTargetDollars[acId] = 0;
        });
        
        // --- PER ACCOUNT CALCULATIONS ---
        for (const accId of accountIds) {
            const atId = accountAtMap[accId];
            const accValue = accountValues[accId] || 0;
            const accDefaults = defaults[atId] || {};
            const accOverrides = overrides[accId] || {};
            
            const hasOverrides = Object.keys(accOverrides).length > 0;
            
            let accTotalEffectiveNonCash = 0;
            
            // Process Standard Asset Classes
            primaryAssetRows.forEach(row => {
                const acId = row.dataset.acId;
                if(acId === 'cash') return;
                
                let effective = 0;
                if (hasOverrides) {
                    effective = accOverrides[acId] || 0;
                } else {
                    effective = accDefaults[acId] || 0;
                }
                
                accTotalEffectiveNonCash += effective;
                
                // Update UI for per-account vTarget (Current - Target) in percent table
                const pctVarSpan = document.getElementById(`var-${accId}-${acId}`);
                if (pctVarSpan) {
                    const varTd = pctVarSpan.parentElement;
                    const targetTd = varTd ? varTd.previousElementSibling : null;
                    const currTd = targetTd ? targetTd.previousElementSibling : null;
                    if (currTd) {
                        const currentAttr = currTd.getAttribute('data-acc-current-pct');
                        const currentPct = parseFloat(currentAttr || '0');
                        const variance = currentPct - effective;
                        pctVarSpan.innerHTML = formatPct(variance);
                        pctVarSpan.className = variance >= 0 ? 'text-success' : 'text-danger';
                    }
                }
                
                // Aggregate Dollars
                const dollars = accValue * (effective / 100);
                
                if (!atTargetDollars[atId]) atTargetDollars[atId] = {};
                if (!atTargetDollars[atId][acId]) atTargetDollars[atId][acId] = 0;
                atTargetDollars[atId][acId] += dollars;
                
                if (!aggTargetDollars[acId]) aggTargetDollars[acId] = 0;
                aggTargetDollars[acId] += dollars;
                
            });
            
            // Process Cash
            let cashEff = 0;
            if (hasOverrides) {
                 if (accOverrides['cash'] !== undefined) {
                      cashEff = accOverrides['cash'];
                 } else {
                      cashEff = Math.max(0, 100 - accTotalEffectiveNonCash);
                 }
            } else {
                 const defTotal = defaultTotals[atId] || 0;
                 cashEff = Math.max(0, 100 - defTotal);
            }

            // Aggregate cash dollars like other asset classes
            const cashDollars = accValue * (cashEff / 100);
            aggCashDollars += cashDollars;
            if (!atCashDollars[atId]) atCashDollars[atId] = 0;
            atCashDollars[atId] += cashDollars;
            
            // ... (Existing Cash Span Updates) ...
            const cashSpan = document.getElementById(`cash-eff-${accId}`);
            if(cashSpan) {
                cashSpan.innerHTML = formatPct(cashEff);
                // ... styling ...
                if (hasOverrides && accOverrides['cash'] !== undefined) cashSpan.classList.add('fw-bold', 'text-primary'); 
                else cashSpan.classList.remove('fw-bold', 'text-primary');
                
                if (Math.abs(accTotalEffectiveNonCash + cashEff - 100) > 0.1) cashSpan.classList.add('text-danger');
                else cashSpan.classList.remove('text-danger');
            }
            
            // Update cash variance (Current - Target) in percent table
            const cashVarSpan = document.getElementById(`cash-var-${accId}`);
            if (cashVarSpan) {
                // Find the cash current cell by looking for the cell with data-acc-current-pct attribute in the cash row
                const cashRow = cashVarSpan.closest('tr');
                const cashCurrentCell = cashRow.querySelector('[data-acc-current-pct]');
                if (cashCurrentCell) {
                    const cashCurrentPct = parseFloat(cashCurrentCell.getAttribute('data-acc-current-pct') || '0');
                    const cashVariance = cashCurrentPct - cashEff;
                    cashVarSpan.innerHTML = formatPct(cashVariance);
                    cashVarSpan.className = cashVariance >= 0 ? 'text-success' : 'text-danger';
                }
            }
            
            // Total Row for Account
            const totSpan = document.getElementById(`total-eff-${accId}`);
            if(totSpan) totSpan.innerHTML = formatPct(accTotalEffectiveNonCash + cashEff);
            
        }
        
        // 4. Update Aggregates (Account Types & Portfolio)
        
        // AT Defaults validation
        for (const atId of allAtIds) {
             const total = defaultTotals[atId] || 0;
             const cashDef = Math.max(0, 100 - total);
             const cashEl = document.getElementById(`cash-default-${atId}`);
             if(cashEl) cashEl.innerHTML = formatPct(cashDef);
             
             const totEl = document.getElementById(`total-default-${atId}`);
             if(totEl) {
                 totEl.innerHTML = formatPct(total + cashDef);
                 totEl.title = `Non-cash total: ${total.toFixed(2)}%`;
                 if (total >= 100.01) totEl.classList.add('text-danger');
                 else totEl.classList.remove('text-danger');
             }
             
             if (total >= 100.01) {
                 valid = false;
                 invalidDefaultTotals.set(atId, {
                     label: atLabels[atId] || atId,
                     total: total,
                 });
             }
        }

        const atTotalValues = dataObj.at_values;
        
        // Track Category Totals (percent table only)
        const categoryTargets = {}; 
        const atCategoryTargets = {}; 
        
        // Standard Assets Rows Update
        primaryAssetRows.forEach(row => {
             const acId = row.dataset.acId;
             const catCode = row.dataset.categoryCode;
             if(acId === 'cash') return;
             
             // 4a. Update Account Type Columns
             for (const [atId, dollarsMap] of Object.entries(atTargetDollars)) {
                  const dollars = dollarsMap[acId] || 0;
                  const totalVal = atTotalValues[atId] || 0;
                  const pct = totalVal > 0 ? (dollars / totalVal * 100) : 0;
                  
                  // % Table
                  const el = document.getElementById(`agg-${atId}-${acId}`);
                  if(el) el.innerHTML = formatPct(pct);

                  // Note: Variance is now pre-calculated in the service layer
                  // and rendered directly in the template. No need to recalculate here.
                  
                  // Money-table cells are now rendered from backend; no JS updates here.

                  // Accumulate Category
                  if (catCode) {
                      if (!atCategoryTargets[atId]) atCategoryTargets[atId] = {};
                      if (!atCategoryTargets[atId][catCode]) atCategoryTargets[atId][catCode] = 0;
                      atCategoryTargets[atId][catCode] += dollars;
                  }
             }
             
             // 4b. Portfolio Total Columns
             const totalDollars = aggTargetDollars[acId] || 0;
             const portPct = portfolioTotal > 0 ? (totalDollars / portfolioTotal * 100) : 0;
             document.getElementById(`row-total-${acId}`).innerHTML = formatPct(portPct);
             
             
             // Pct Variance Logic (Existing) ...
              const portTotalCell = document.getElementById(`row-total-${acId}`).parentElement;
              const portCurrCell = portTotalCell ? portTotalCell.previousElementSibling : null;
              if (portCurrCell) {
                  const currentText = portCurrCell.innerText.replace('%','');
                  const currentPct = parseFloat(currentText) || 0;
                   const variance = currentPct - portPct;
                   const varEl = document.getElementById(`row-var-${acId}`);
                   varEl.innerHTML = formatPct(variance);
                  varEl.className = 'text-end pe-2 table-active fw-bold ' + (variance >= 0 ? 'text-success' : 'text-danger');
              }
             
             if (catCode) {
                 if (!categoryTargets[catCode]) categoryTargets[catCode] = 0;
                 categoryTargets[catCode] += totalDollars;
             }
        });
        
        // 5. Category Subtotals
        const catCodes = new Set();
        primaryAssetRows.forEach(r => {
             if (r.dataset.categoryCode) catCodes.add(r.dataset.categoryCode);
        });
        
        catCodes.forEach(catCode => {
             // ... Existing Pct Logic ... 
             const catDollars = categoryTargets[catCode] || 0;
             const catTargetPct = portfolioTotal > 0 ? (catDollars / portfolioTotal * 100) : 0;
             document.getElementById(`sub-total-target-${catCode}`).innerHTML = formatPct(catTargetPct);
             
             // Money-table category cells are rendered from backend; no JS updates here.

             // AT Subtotals
             for (const atId of Object.keys(defaultTotals)) {
                  const targDollars = (atCategoryTargets[atId] && atCategoryTargets[atId][catCode]) ? atCategoryTargets[atId][catCode] : 0;
                  const totalVal = atTotalValues[atId] || 0;
                  const wtPct = totalVal > 0 ? (targDollars / totalVal * 100) : 0;
                  
                  // % Table Updates
                  const aggEl = document.getElementById(`sub-agg-${atId}-${catCode}`);
                  if (aggEl) aggEl.innerHTML = formatPct(wtPct);
                  
                  // Money Table Target cells are rendered from backend; no JS updates here.
                  
                  // Money Table Variance cells are rendered from backend; no JS updates here.
             }
             
             // Account Subtotals (Money Table)
             for (const accId of accountIds) {
                  // We need to sum effective dollars for this account + category
                  // Easier to modify the main loops to track this? 
                  // Or just assume the logic works if row by row works.
                  // For now, let's leave account subtotals in money table as -- if too complex to wire up relative to Pct logic.
                  // Wait, row logic didn't update Money Table Account Subtotal Cells? 
                  // Because we didn't store account-category dollars in a map during main loop.
                  // TODO: Add account-category dollar tracking if critical.
             }
        });
        
        // 6. Cash aggregate targets (Account Types + Portfolio)
        for (const [atId, dollars] of Object.entries(atCashDollars)) {
            const totalVal = atTotalValues[atId] || 0;
            const pct = totalVal > 0 ? (dollars / totalVal * 100) : 0;
            const el = document.getElementById(`cash-agg-${atId}`);
            if (el) el.innerHTML = formatPct(pct);
        }

        const cashPortfolioPct = portfolioTotal > 0 ? (aggCashDollars / portfolioTotal * 100) : 0;
        const cashTotalEl = document.getElementById('cash-total');
        if (cashTotalEl) cashTotalEl.innerHTML = formatPct(cashPortfolioPct);

        // 6. Cash and money-table grand totals are rendered from backend; no JS updates here.

        saveButtons.forEach(btn => {
            btn.disabled = !valid;
            if (!valid) {
                const parts = Array.from(invalidDefaultTotals.values()).map(v => {
                    return `Total allocation for ${v.label} exceeds 100% (${v.total.toFixed(2)}%)`;
                });
                btn.title = parts.join(' | ');
            } else {
                btn.title = '';
            }
        });
    }
    
    allInputs.forEach(inp => inp.addEventListener('input', updateCalculations));
    updateCalculations();
});
</script>
{% endblock %}
